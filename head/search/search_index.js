var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Retis - Tracing packets in the Linux networking stack &amp; friends","text":"<p>This is brand new version 4.0.0!!!</p> <p>Retis aims at improving visibility of what happens in the Linux networking stack and different control and/or data paths, some of which can be in userspace. It works either in a single collect &amp; display phase, or in a collect then process fashion.</p>"},{"location":"index.html#event-collection","title":"Event collection","text":"<p>The entry point for most of the use cases is the <code>collect</code> command, which will install probes and gather events for instant reporting on the console or for later processing writing events to a file (or both). In addition to collect-level options, <code>retis collect</code> has the concept of collectors. Those collectors can be enabled individually and will act on different parts of the networking stack to retrieve specific information.</p> <p>Currently supported collectors are listed below. By default Retis will try to load all collectors if their individual requirements are met (e.g. the <code>ovs</code> collector needs the OpenVSwitch kernel module to be loaded) but collectors can be explicitly selected too (here if prerequisites are not met an error will be returned). If no specific option is used, Retis will by default output the events to the console.</p> <pre><code>$ retis collect\n00:42:00 [INFO] Collector(s) started: skb-tracking, skb, skb-drop, ovs\n00:42:01 [INFO] 5 probe(s) loaded\n...\n$ retis collect -c skb,skb-drop\n00:42:00 [INFO] 4 probe(s) loaded\n...\n</code></pre> <p>In order to allow post-processing, events need to be stored in a file. This is done using the <code>-o</code> option. To also output the events to the console in parallel, one can use <code>--print</code>.</p> <pre><code>$ retis collect -c skb,skb-drop,skb-tracking -o retis.data\n00:42:00 [INFO] 4 probe(s) loaded\n...\n$ retis collect -c skb,skb-drop,skb-tracking -o retis.data --print\n00:42:00 [INFO] 4 probe(s) loaded\n...\n</code></pre>"},{"location":"index.html#collectors","title":"Collectors","text":"<p>Collectors are responsible for filling events and target specific areas or data types. Some, but not all, install specific probes to build their events. Currently supported collectors are:</p> Collector Data collected Installs probes skb Packet information No skb-drop Drop reason Yes (1) skb-tracking Packet tracking id No[^1] ovs OpenVSwitch data Yes (many) nft Nftables context Yes (1) <p>See <code>retis collect --help</code> for a description of each collector and its command line arguments.</p> <p>[^1]: Probes for tracking packets are always installed by the core.</p>"},{"location":"index.html#post-processing","title":"Post-processing","text":"<p>Events stored in a file can be formatted and displayed to the console using the simple <code>print</code> command.</p> <pre><code>$ retis print retis.data\n...\n</code></pre> <p>But events can also be post-processed. Retis allows to trace packets across the networking stack and as such the same packet can be seen multiple times (e.g. in the IP stack, TCP stack, OvS stack &amp; netfilter stack; sometimes multiple times in each subsystem depending on which probes where loaded). The <code>sort</code> command uses information reported by the <code>skb-tracking</code> and the <code>ovs</code> collectors to identify unique packets and group/reorder the events so the same packet can be efficiently tracked in the stack.</p> <pre><code>$ retis collect --allow-system-changes -p kprobe:ip_local_deliver \\\n        --nft-verdicts drop -f 'udp port 8080' -o retis.data --print\n...\n$ retis sort retis.data\n\n3316376152002 [swapper/2] 0 [k] ip_local_deliver #304276b119fffff9847c36ba800 (skb 18446630032886128640) n 0\n  if 2 (eth0) rxif 2 172.16.42.1.40532 &gt; 172.16.42.2.8080 ttl 64 tos 0x0 id 14042 off 0 [DF] len 32 proto UDP (17) len 4\n  + 3316376220653 [swapper/2] 0 [k] __nft_trace_packet #304276b119fffff9847c36ba800 (skb 18446630032886128640) n 1\n    if 2 (eth0) rxif 2 172.16.42.1.40532 &gt; 172.16.42.2.8080 ttl 64 tos 0x0 id 14042 off 0 [DF] len 32 proto UDP (17) len 4\n    table firewalld (1) chain filter_IN_FedoraServer (202) handle 215 drop\n  + 3316376224687 [swapper/2] 0 [tp] skb:kfree_skb #304276b119fffff9847c36ba800 (skb 18446630032886128640) n 2 drop (NETFILTER_DROP)\n    if 2 (eth0) rxif 2 172.16.42.1.40532 &gt; 172.16.42.2.8080 ttl 64 tos 0x0 id 14042 off 0 [DF] len 32 proto UDP (17) len 4\n</code></pre>"},{"location":"index.html#profiles-and-customization","title":"Profiles and customization","text":"<p>Retis has the concept of profiles, which are a predefined set of cli arguments (e.g. collectors for the <code>collect</code> command). Profiles are meant to improve user experience to provide a comprehensive and consistent configuration to Retis aimed at operating on pre-defined topics.</p> <pre><code>$ retis -p generic collect\n...\n</code></pre> <p>Available profiles can be listed using the <code>profile</code> command.</p> <pre><code>$ retis profile list\n...\n</code></pre> <p>Profiles can be extended by using cli arguments. Cli arguments can also be used without a profile. One example is adding probes while collecting events.</p> <pre><code>$ retis -p dropmon collect -p tp:skb:consume_skb\n...\n$ retis collect -p tp:skb:kfree_skb -p kprobe:ovs_ct_clear\n...\n</code></pre> <p>New profiles can be written and used if stored in <code>/etc/retis/profiles</code> or <code>$HOME/.config/profiles</code>. Here is an example profile with inlined comments. If a profile is generic enough, consider contributing it!</p>"},{"location":"index.html#filtering","title":"Filtering","text":"<p>Tracing packets can generate a lot of events, some of which are not interesting. Retis implements a filtering logic to only report packets matching the filter or being tracked (see tracking).</p> <p>Retis uses a pcap-filter syntax. See <code>man pcap-filter</code> for an overview on the syntax.</p> <pre><code>$ retis collect -f 'tcp port 443'\n...\n</code></pre>"},{"location":"index.html#tracking","title":"Tracking","text":"<p>Retis does its best to track packets in the networking stack, and does it in different ways. Note that tracking packets is not a built-in feature of the Linux kernel and doing so is complex and cannot be 100% foolproof (but of course bugs should be reported and fixed).</p> <ol> <li> <p>A Retis core built-in feature generates unique identifiers by tracking the    data part of socket buffers.    The socket buffer is also included in the identifier so we can track clones    and friends. This core skb tracking logic is used by the filtering part for    Retis to track packets after they were modified (e.g. NAT). Full details on    the implementation can be found    in the sources.</p> </li> <li> <p>A collector, <code>skb-tracking</code>, retrieves the core tracking information (unique    identifier and socket buffer address) and reports it in the event. Without    enabling this collector, skb tracking information won't be reported and can't    be used at post-processing time.</p> </li> <li> <p>The <code>ovs</code> collector tracks packets in upcalls so we can follow a packet    being sent to the OpenVSwitch user-space daemon, even if it is re-injected    later on.</p> </li> </ol>"},{"location":"CONTRIBUTING.html","title":"Contribution guidelines","text":"<p>Thank you for investing your time and considering contributing to Retis! :tada:</p> <p>This guide documents the process to get changes merged into this project, what one should expect, as well as prerequisites for pull-requests and patches to be considered acceptable.</p>"},{"location":"CONTRIBUTING.html#table-of-contents","title":"Table of contents","text":"<ul> <li>Reporting bugs</li> <li>Suggesting new features</li> <li>Code contribution</li> </ul>"},{"location":"CONTRIBUTING.html#reporting-bugs","title":"Reporting bugs","text":"<p>Following the guidelines will help the community understand bug reports, which in turns will help in reproducing, triaging and fixing those bugs.</p>"},{"location":"CONTRIBUTING.html#before-submitting-the-report","title":"Before submitting the report","text":"<ol> <li>Check for similar opened or closed issues. If a similar issue is still    opened, please add a comment there.</li> <li>Check the version used when the bug was triggered. If it was not the latest,    please reproduce with it.</li> </ol>"},{"location":"CONTRIBUTING.html#submitting-a-good-bug-report","title":"Submitting a good bug report","text":"<ol> <li>Use a clear, concise and descriptive title.</li> <li>Describe how to reproduce the bug, in clear exact steps, with examples. The    community should not have to guess extra steps, configuration, prerequisites    and spend lot of time gathering this information to work on fixing a bug.</li> <li>How reliable are those steps to reproduce the issue?</li> <li>Describe the outcome of those steps.</li> <li>Then describe what would have been expected and why.</li> <li>If it is performances related, include numbers.</li> </ol>"},{"location":"CONTRIBUTING.html#following-up-on-the-report","title":"Following-up on the report","text":"<ul> <li>It's OK to ping once or twice.</li> <li>But give time to the community to reproduce and come up with a solution.</li> <li>Also note we all have limited time and prioritize things.</li> </ul>"},{"location":"CONTRIBUTING.html#suggesting-new-features","title":"Suggesting new features","text":"<p>Features requirement vary depending on users, use cases, priorities, etc. But expressing an interest is valuable as it can help prioritizing things and shaping the actual behavior.</p>"},{"location":"CONTRIBUTING.html#before-suggesting-a-new-feature","title":"Before suggesting a new feature","text":"<ol> <li>Check the feature isn't already available. See the tool help.</li> <li>Check it is not already being planned by looking at the different    milestones and    issues. If a matching issue is    found, please comment on it to express an interest and make suggestions.</li> </ol>"},{"location":"CONTRIBUTING.html#adding-an-issue-to-request-a-new-feature","title":"Adding an issue to request a new feature","text":"<ol> <li>Use a clear, concise and descriptive title.</li> <li>Describe the environment on which the feature would be used and provide    value.</li> <li>Provide a detailed explanation of what you'd like to be implemented, the    expected output and behavior.</li> <li>If applicable, explain what the current behavior is lacking and how different    you'd like it to be.</li> <li>Understand we have limited time and do prioritize things. In this regard,    external contributions for new features are highly recommended and can have a    great impact in choosing the direction of the project.</li> </ol>"},{"location":"CONTRIBUTING.html#code-contribution","title":"Code contribution","text":"<p>Looking for topics to work on? Please have a look at issues triaged as good first issues and/or help wanted.</p>"},{"location":"CONTRIBUTING.html#guidelines","title":"Guidelines","text":"<ol> <li>Follow the coding style.</li> <li>Document functions, structures (including members), enums, ..., and the code    itself. You can look at the existing code for understanding what level of    documentation we expect.</li> <li>Add unit tests.</li> <li>Base new work on top of the <code>main</code> branch.</li> </ol>"},{"location":"CONTRIBUTING.html#coding-style","title":"Coding style","text":"<p>We strictly follow the Rust coding style as enforced by <code>rustfmt</code> and have a strong preference for the Linux kernel and particularly its networking flavor coding style for the BPF parts.</p>"},{"location":"CONTRIBUTING.html#opening-a-pull-request","title":"Opening a pull-request","text":"<ol> <li>Before opening the pull-request, test the changes. Yes, even for those simple    one-liner last minute changes.</li> <li>Check the following commands do not return an error:</li> <li><code>cargo fmt --check</code></li> <li><code>cargo clippy -- -D warnings</code></li> <li><code>cargo test</code>, or to include runtime tests,       <code>CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_RUNNER='sudo' cargo test --features=test_cap_bpf</code></li> <li>Make sure commits are    signed off.</li> <li>Use a clear, concise and descriptive title.</li> <li>If the pull-request is linked to an issue, or based on top of another    pull-request; reference those.</li> <li>Describe the environment on which the feature is used and provide value.</li> <li>Provide a detailed explanation of why the feature was added, how it was done    and what is the expected output and behavior.</li> <li>If applicable, provide a step-by-step guide on how to test the feature.</li> <li>For pull-requests demonstrating a change to start a discussion, please add    \"[RFC]\" in the pull-request title. Once in a state ready to be formally    reviewed for inclusion, remove it.</li> </ol>"},{"location":"CONTRIBUTING.html#following-up-on-the-pull-request","title":"Following-up on the pull-request","text":"<ol> <li>As new versions of the pull-request are pushed, make sure to mark applicable    conversations as    resolved.</li> <li>If the pull-request has a conflict and cannot be merged, please rebase on the    latest <code>main</code>. This can happen at any time, e.g. when other pull-requests are    being merged.</li> </ol>"},{"location":"examples.html","title":"Examples","text":""},{"location":"examples.html#simple-copypaste-examples","title":"Simple copy/paste examples","text":"<p>Drop monitor-like, listing packets being dropped by the kernel with an associated stack trace and drop reason (in the example below, no socket was found).</p> <pre><code>$ retis -p dropmon collect\n00:42:00 [INFO] 4 probe(s) loaded\n\n3392678938917 [nc] 2311 [tp] skb:kfree_skb drop (NO_SOCKET)\n    bpf_prog_3a0ef5414c2f6fca_sd_devices+0xa0ad\n    bpf_prog_3a0ef5414c2f6fca_sd_devices+0xa0ad\n    bpf_trace_run3+0x52\n    kfree_skb_reason+0x8f\n    tcp_v6_rcv+0x77\n    ip6_protocol_deliver_rcu+0x6b\n    ip6_input_finish+0x43\n    __netif_receive_skb_one_core+0x62\n    process_backlog+0x85\n    __napi_poll+0x28\n    net_rx_action+0x2a4\n    __do_softirq+0xd1\n    do_softirq.part.0+0x5f\n    __local_bh_enable_ip+0x68\n    __dev_queue_xmit+0x293\n    ip6_finish_output2+0x2a3\n    ip6_finish_output+0x160\n    ip6_xmit+0x2c0\n    inet6_csk_xmit+0xe9\n    __tcp_transmit_skb+0x534\n    tcp_connect+0xaf6\n    tcp_v6_connect+0x515\n    __inet_stream_connect+0x103\n    inet_stream_connect+0x3a\n    __sys_connect+0xa8\n    __x64_sys_connect+0x18\n    do_syscall_64+0x5d\n    entry_SYSCALL_64_after_hwframe+0x72\n  if 1 (lo) rxif 1 ::1.60634 &gt; ::1.80 ttl 64 label 0x9c404 len 40 proto TCP (6) flags [S] seq 3918324244 win 65476\n...\n</code></pre> <p>Monitoring packets dropped by netfilter, the exact nft rule can be retrieved using <code>nft -a list table ...</code>.</p> <pre><code>$ retis -p nft-dropmon collect --allow-system-changes\n00:42:00 [INFO] 4 probe(s) loaded\n\n3443313082998 [swapper/0] 0 [k] __nft_trace_packet\n    __nft_trace_packet+0x1\n    nft_do_chain+0x3ef\n    nft_do_chain_inet+0x54\n    nf_hook_slow+0x42\n    ip_local_deliver+0xd0\n    ip_sublist_rcv_finish+0x7e\n    ip_sublist_rcv+0x186\n    ip_list_rcv+0x13d\n    __netif_receive_skb_list_core+0x29d\n    netif_receive_skb_list_internal+0x1d1\n    napi_complete_done+0x72\n    virtnet_poll+0x3ce\n    __napi_poll+0x28\n    net_rx_action+0x2a4\n    __do_softirq+0xd1\n    __irq_exit_rcu+0xbe\n    common_interrupt+0x86\n    asm_common_interrupt+0x26\n    pv_native_safe_halt+0xf\n    default_idle+0x9\n    default_idle_call+0x2c\n    do_idle+0x226\n    cpu_startup_entry+0x1d\n    __pfx_kernel_init+0x0\n    arch_call_rest_init+0xe\n    start_kernel+0x71e\n    x86_64_start_reservations+0x18\n    x86_64_start_kernel+0x96\n    __pfx_verify_cpu+0x0\n  if 2 (eth0) rxif 2 172.16.42.1.52294 &gt; 172.16.42.2.8080 ttl 64 tos 0x0 id 37968 off 0 [DF] len 60 proto TCP (6) flags [S] seq 1971640626 win 64240\n  table firewalld (1) chain filter_IN_FedoraServer (202) handle 215 drop\n...\n$ nft -a list table inet firewalld\n...\n    chain filter_IN_FedoraServer { # handle 202\n...\n        jump filter_INPUT_POLICIES_post # handle 214\n        meta l4proto { icmp, ipv6-icmp } accept # handle 273\n        reject with icmpx admin-prohibited # handle 215         &lt;- This one\n    }\n...\n</code></pre>"},{"location":"install.html","title":"Installation","text":"<p>Retis can be installed from COPR for rpm-compatible distributions, from a container image or from sources.</p>"},{"location":"install.html#copr","title":"COPR","text":"<p>RPM packages for Fedora (currently supported releases including Rawhide), RHEL (&gt;= 8) and EPEL (&gt;= 8) are available.</p> <pre><code>$ dnf -y copr enable @retis/retis\n$ dnf -y install retis\n$ retis --help\n</code></pre> <p>Or on older distributions,</p> <pre><code>$ yum -y copr enable @retis/retis\n$ yum -y install retis\n$ retis --help\n</code></pre>"},{"location":"install.html#container-image","title":"Container image","text":"<p>The preferred method to run Retis in a container is by using the provided retis_in_container.sh script,</p> <pre><code>$ curl -O https://raw.githubusercontent.com/retis-org/retis/main/tools/retis_in_container.sh\n$ chmod +x retis_in_container.sh\n$ ./retis_in_container.sh --help\n</code></pre> <p>The Retis container can also be run manually,</p> <pre><code>$ podman run --privileged --rm -it --pid=host \\\n      --cap-add SYS_ADMIN --cap-add BPF --cap-add SYSLOG \\\n      -v /sys/kernel/btf:/sys/kernel/btf:ro \\\n      -v /sys/kernel/debug:/sys/kernel/debug:ro \\\n      -v /boot/config-$(uname -r):/kconfig:ro \\\n      -v $(pwd):/data:rw \\\n      quay.io/retis/retis:latest --help\n</code></pre> <ul> <li> <p>Or using <code>docker</code> in place of <code>podman</code> in the above.</p> </li> <li> <p>When running on CoreOS, Fedora Silverblue and friends replace <code>-v   /boot/config-$(uname -r):/kconfig:ro</code> with <code>-v /lib/modules/$(uname   -r)/config:/kconfig:ro</code> in the above.</p> </li> </ul> <p>The <code>/data</code> container mount point is used to allow storing persistent data for future use (e.g. logged events using the <code>-o</code> cli option).</p>"},{"location":"install.html#from-sources","title":"From sources","text":"<p>Retis depends on the following (in addition to Git and Cargo): - rust &gt;= 2021 - clang - libelf - libpcap - llvm - make - pkg-config</p> <p>On Fedora, one can run:</p> <pre><code>$ dnf -y install git cargo clang elfutils-libelf-devel \\\n        libpcap-devel llvm make pkgconf-pkg-config\n</code></pre> <p>On Ubuntu:</p> <pre><code>$ apt update\n$ apt -y install git cargo clang libelf-dev libpcap-dev llvm make pkg-config\n</code></pre> <p>Then, to download and build Retis:</p> <pre><code>$ git clone --depth 1 https://github.com/retis-org/retis; cd retis\n$ cargo build --release\n$ ./target/release/retis --help\n</code></pre> <p>Finally, profiles should be installed in either <code>/etc/retis/profiles</code> or <code>$HOME/.config/retis/profiles</code>.</p> <pre><code>$ mkdir -p /etc/retis/profiles\n$ cp profiles/* /etc/retis/profiles\n</code></pre>"},{"location":"install.html#running-as-non-root","title":"Running as non-root","text":"<p>Retis can run as non-root if it has the right capabilities. Note that doing this alone often means <code>debugfs</code> won't be available as it's usually owned by <code>root</code> only and Retis won't be able to fully filter probes.</p> <pre><code>$ sudo setcap cap_sys_admin,cap_bpf,cap_syslog=ep $(which retis)\n$ retis collect\n</code></pre>"},{"location":"known_issues.html","title":"Limitations","text":"<p>Known and current limitations:</p> <ul> <li> <p>By default Retis does not modify the system (e.g. load kernel modules, change   the configuration, add a firewalling rule). This is done on purpose but might   mean some prerequisites will be missing if not added manually. The only   example for now is the <code>nft</code> module that requires a specific nft rule to be   inserted. If that rule is not there, no nft event will be reported. To allow   Retis to modify the system, use the <code>--allow-system-changes</code> option when   running the <code>collect</code> command. See <code>retis collect --help</code> for further details   about changes applied to the system.</p> </li> <li> <p>Retis operates mainly on <code>struct sk_buff</code> objects meaning a good part of   locally generated traffic can't be traced at the moment. E.g. locally   generated traffic from a container can be traced when it exits the container.</p> </li> <li> <p>Profiles combination might fail if flags are used multiple times or if some   arguments are incompatible. Use with care.</p> </li> </ul> <p>Additional notes (not strictly limitations):</p> <ul> <li> <p>Filtering &amp; tracking packets being modified can only work if the packet is at   least seen once in a form where it can be matched against the filter. E.g.   tracking SNATed packets only in <code>skb:consume_skb</code> with a filter on the   original address won't generate any event.</p> </li> <li> <p>Some fields present in the packet might not be reported when probes are early   in the stack, while being shown in later ones. This is because Retis probes   rely on the networking stack knowledge of the packet and if some parts weren't   processed yet they can't be reported. E.g. TCP ports won't be reported from   <code>kprobe:ip_rcv</code>.</p> </li> </ul>"},{"location":"requirements.html","title":"Requirements","text":"<p>All requirements are for commands collecting events, for now only <code>collect</code>.</p> <p>Mandatory requirements:</p> <ul> <li> <p>Retis needs <code>CAP_SYS_ADMIN</code>, <code>CAP_BPF</code>, <code>CAP_SYSLOG</code> and access to all files   listed in the requirements.</p> </li> <li> <p>The following kernel configuration:</p> </li> <li><code>CONFIG_BPF_SYSCALL=y</code>.</li> <li> <p><code>CONFIG_DEBUG_INFO_BTF=y</code> to parse kernel functions and types.</p> </li> <li> <p>Access to <code>/sys/kernel/btf</code> and <code>/proc/kallsyms</code>.</p> </li> </ul> <p>Not strictly required but best for user experience and feature scope:</p> <ul> <li>The following kernel configuration:</li> <li><code>CONFIG_KPROBES=y</code> to allow using kprobes.</li> <li> <p><code>CONFIG_PERF_EVENTS=y</code> to retrieve stack traces (&amp; probably more).</p> </li> <li> <p><code>debugfs</code> mounted to <code>/sys/kernel/debug</code> to allow filtering functions and   events.</p> </li> <li> <p><code>/etc/os-release</code> to gather information about the current distribution.</p> </li> </ul>"},{"location":"requirements.html#supported-operating-systems","title":"Supported operating systems","text":"<p>Those are operating systems we know are compatible with running Retis. Of course the list is not exhaustive (let us know if we can add new lines).</p> Operating system Notes Fedora All officially supported versions including Rawhide RHEL9 CentOS Stream 9 RHEL8 &gt;= 8.6 Ubuntu Jammy"}]}