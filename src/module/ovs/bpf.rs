//! Rust<>BPF types definitions for the ovs module.
//! Please keep this file in sync with its BPF counterpart in bpf/.

use anyhow::{bail, Result};
use plain::Plain;

use crate::{
    core::events::{
        bpf::{parse_raw_section, BpfRawSection},
        EventField,
    },
    event_field,
};

/// Types of events that can be generated by the ovs module.
#[derive(Debug, Eq, Hash, PartialEq)]
pub(crate) enum OvsEventType {
    /// Upcall tracepoint.
    Upcall = 0,
    /// Upcall enqueue kretprobe.
    UpcallEnqueue = 1,
    /// Upcall received in userspace.
    RecvUpcall = 2,
    /// Flow operation
    Operation = 3,
    /// Execute action tracepoint.
    ActionExec = 4,
    /// OUTPUT action specific data.
    OutputAction = 5,
}

impl OvsEventType {
    pub(super) fn from_u8(val: u8) -> Result<OvsEventType> {
        use OvsEventType::*;
        let owner = match val {
            0 => Upcall,
            1 => UpcallEnqueue,
            2 => RecvUpcall,
            3 => Operation,
            4 => ActionExec,
            5 => OutputAction,
            x => bail!("Can't construct a OvsEventType from {}", x),
        };
        Ok(owner)
    }
}

/// OVS Upcall data.
#[derive(Default)]
#[repr(C, packed)]
struct UpcallEvent {
    /// Upcall command. Holds OVS_PACKET_CMD:
    ///   OVS_PACKET_CMD_UNSPEC   = 0
    ///   OVS_PACKET_CMD_MISS     = 1
    ///   OVS_PACKET_CMD_ACTION   = 2
    ///   OVS_PACKET_CMD_EXECUTE  = 3
    cmd: u8,
    /// Upcall port.
    port: u32,
}
unsafe impl Plain for UpcallEvent {}

pub(super) fn unmarshall_upcall(raw: &BpfRawSection, fields: &mut Vec<EventField>) -> Result<()> {
    let event = parse_raw_section::<UpcallEvent>(raw)?;

    fields.push(event_field!("upcall_port", event.port));
    fields.push(event_field!("cmd", event.cmd));
    fields.push(event_field!("event_type", "upcall".to_string()));
    Ok(())
}

/// OVS action event data.
#[derive(Default)]
#[repr(C, packed)]
struct ActionEvent {
    /// Action to be executed.
    action: u8,
    /// Recirculation id.
    recirc_id: u32,
}

unsafe impl Plain for ActionEvent {}

pub(super) fn unmarshall_exec(raw: &BpfRawSection, fields: &mut Vec<EventField>) -> Result<()> {
    let event = parse_raw_section::<ActionEvent>(raw)?;

    // Values from enum ovs_action_attr (uapi/linux/openvswitch.h).
    let action_str = match event.action {
        0 => "unspecified",
        1 => "output",
        2 => "userspace",
        3 => "set",
        4 => "push_vlan",
        5 => "pop_vlan",
        6 => "sample",
        7 => "recirc",
        8 => "hash",
        9 => "push_mpls",
        10 => "pop_mpls",
        11 => "set_masked",
        12 => "ct",
        13 => "trunc",
        14 => "push_eth",
        15 => "pop_eth",
        16 => "ct_clear",
        17 => "push_nsh",
        18 => "pop_nsh",
        19 => "meter",
        20 => "clone",
        21 => "check_pkt_len",
        22 => "add_mpls",
        23 => "dec_ttl",
        val => bail!("Unsupported action id {val}"),
    };

    fields.push(event_field!("action", action_str.to_string()));
    fields.push(event_field!("recirc_id", event.recirc_id));
    fields.push(event_field!("event_type", "action_execute".to_string()));
    Ok(())
}

/// OVS output action data.
#[derive(Default)]
#[repr(C, packed)]
struct OutputAction {
    /// Output port.
    port: u32,
}
unsafe impl Plain for OutputAction {}

pub(super) fn unmarshall_output(raw: &BpfRawSection, fields: &mut Vec<EventField>) -> Result<()> {
    let event = parse_raw_section::<OutputAction>(raw)?;

    fields.push(event_field!("port", event.port));
    Ok(())
}

/// OVS Recv Upcall data.
#[derive(Default)]
#[repr(C, packed)]
struct RecvUpcall {
    r#type: u32,
    pkt_size: u32,
    key_size: u64,
}
unsafe impl Plain for RecvUpcall {}

pub(super) fn unmarshall_recv(raw: &BpfRawSection, fields: &mut Vec<EventField>) -> Result<()> {
    let event = parse_raw_section::<RecvUpcall>(raw)?;

    fields.push(event_field!("upcall_type", event.r#type));
    fields.push(event_field!("pkt_size", event.pkt_size));
    fields.push(event_field!("key_size", event.key_size));
    fields.push(event_field!("event_type", "recv_upcall".to_string()));
    Ok(())
}

/// OVS Operation data.
#[derive(Default)]
#[repr(C, packed)]
struct OvsOperation {
    op_type: u8,
}
unsafe impl Plain for OvsOperation {}

pub(super) fn unmarshall_operation(
    raw: &BpfRawSection,
    fields: &mut Vec<EventField>,
) -> Result<()> {
    let event = parse_raw_section::<OvsOperation>(raw)?;

    match event.op_type {
        0 => fields.push(event_field!("op_type", "exec".to_string())),
        1 => fields.push(event_field!("op_type", "put".to_string())),
        _ => bail!("Unknown operation type {0}", event.op_type),
    };
    fields.push(event_field!("event_type", "flow_operation".to_string()));

    Ok(())
}

/// OVS Operation data.
#[derive(Default)]
#[repr(C, packed)]
struct UpcallEnqueue {
    ret: i32,
    cmd: u8,
    port: u32,
}
unsafe impl Plain for UpcallEnqueue {}

pub(super) fn unmarshall_upcall_enqueue(
    raw: &BpfRawSection,
    fields: &mut Vec<EventField>,
) -> Result<()> {
    let event = parse_raw_section::<UpcallEnqueue>(raw)?;

    fields.push(event_field!("return", event.ret));
    fields.push(event_field!("upcall_port", event.port));
    fields.push(event_field!("cmd", event.cmd));
    fields.push(event_field!("event_type", "upcall_enqueue".to_string()));
    Ok(())
}
