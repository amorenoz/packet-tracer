#![allow(dead_code)]

use std::io::{Error, Result};
use std::mem;
use std::os::raw::c_long;

use anyhow::bail;

// Embed in a mod to skip the linter
mod bpf_gen {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]
    // Clippy warns for code generated by bindgen,
    // skip it for this module
    #![allow(clippy::all)]
    include!(concat!(env!("OUT_DIR"), "/bpf_gen.rs"));
}

pub(crate) use bpf_gen::*;

fn bpf_sys(cmd: bpf_gen::bpf_cmd, attr: &bpf_gen::bpf_attr, size: u32) -> c_long {
    unsafe { libc::syscall(libc::SYS_bpf, cmd, attr, size) }
}

pub(crate) fn bpf(cmd: bpf_gen::bpf_cmd, attr: &bpf_gen::bpf_attr) -> Result<u32> {
    let r = bpf_sys(cmd, attr, mem::size_of::<bpf_gen::bpf_attr>() as u32);
    if r < 0 {
        return Err(Error::last_os_error());
    }

    Ok(r as u32)
}

pub(crate) fn bpf_unload(fd: u32) -> Result<()> {
    let r = unsafe { libc::close(fd as libc::c_int) };
    if r < 0 {
        return Err(Error::last_os_error());
    }

    Ok(())
}

fn btf_get_fd(id: u32) -> anyhow::Result<u32> {
    let mut attrs: bpf_gen::bpf_attr = unsafe { std::mem::zeroed() };
    let btf_get_fd_attrs = unsafe { &mut attrs.__bindgen_anon_6.__bindgen_anon_1 };

    btf_get_fd_attrs.btf_id = id;

    let res = bpf(bpf_gen::bpf_cmd::BPF_BTF_GET_FD_BY_ID, &attrs)?;
    Ok(res)
}

fn obj_get_info(fd: u32, info: &[u8]) -> anyhow::Result<u32> {
    let mut attrs: bpf_gen::bpf_attr = unsafe { std::mem::zeroed() };
    let info_attrs = unsafe { &mut attrs.info };

    info_attrs.bpf_fd = fd;
    info_attrs.info = info.as_ptr() as u64;
    info_attrs.info_len = info.len() as u32;

    let res = bpf(bpf_gen::bpf_cmd::BPF_OBJ_GET_INFO_BY_FD, &attrs)?;
    Ok(res)
}

pub(crate) fn gen_dummy_func_info_rec(btf_tid: u32) -> (bpf_gen::bpf_func_info, usize, u32) {
    (
        bpf_gen::bpf_func_info {
            type_id: btf_tid,
            insn_off: 0,
        },
        std::mem::size_of::<bpf_gen::bpf_func_info>(),
        1,
    )
}

pub(crate) fn load_btf(btf: &[u8]) -> anyhow::Result<u32> {
    let mut attrs: bpf_gen::bpf_attr = unsafe { std::mem::zeroed() };
    let btf_load_attrs = unsafe { &mut attrs.__bindgen_anon_7 };

    btf_load_attrs.btf = btf.as_ptr() as u64;
    btf_load_attrs.btf_size = btf.len() as u32;

    let ret = bpf(bpf_gen::bpf_cmd::BPF_BTF_LOAD, &attrs)?;
    Ok(ret)
}

pub(crate) fn get_btf_from_fd(prog_fd: u32) -> anyhow::Result<Vec<u8>> {
    let prog_info: bpf_gen::bpf_prog_info = unsafe { std::mem::zeroed() };

    if prog_fd == 0 {
        bail!("Invalid program file descriptor")
    }

    obj_get_info(prog_fd, unsafe {
        std::slice::from_raw_parts(
            &prog_info as *const _ as *const u8,
            std::mem::size_of::<bpf_gen::bpf_prog_info>(),
        )
    })?;

    let prog_btf_id = match prog_info.btf_id {
        id if id > 0 => id,
        id => bail!("Invalid bpf prog btf fd ({id})"),
    };

    let btf_fd = btf_get_fd(prog_btf_id)?;

    let mut btf_info: bpf_gen::bpf_btf_info = unsafe { std::mem::zeroed() };
    let mut btf_buff = vec![0u8; 2048];

    let mut resized = false;

    loop {
        btf_info.btf = btf_buff.as_ptr() as u64;

        obj_get_info(btf_fd, unsafe {
            std::slice::from_raw_parts(
                &btf_info as *const _ as *const u8,
                std::mem::size_of::<bpf_gen::bpf_btf_info>(),
            )
        })?;

        if btf_info.btf_size <= btf_buff.len() as u32 {
            break;
        }

        if !resized {
            btf_buff.resize(btf_info.btf_size as usize, 0);
            resized = true;
        } else {
            bail!("Unable to retrieve btf data (buff too small)")
        }
    }

    Ok(btf_buff)
}

#[cfg(test)]
mod tests {
    use std::ffi::CString;
    use std::{ptr, str};

    use super::*;

    const LOG_SIZE: usize = 64 * 1024;
    const INSN_SIZE: usize = 8;

    #[test]
    #[cfg_attr(not(feature = "test_cap_bpf"), ignore)]
    fn load_xdp_insns() {
        let log_buff: [u8; LOG_SIZE] = [0; LOG_SIZE];

        // The bytecode below was generated from the following:
        // int xdp_prog_simple(struct xdp_md *ctx)
        // {
        //     if (!ctx)
        //         return XDP_PASS;
        //
        //     if ((__u16 *)ctx->data + 1 > (__u16 *)ctx->data_end)
        //         return XDP_PASS;
        //
        //     __u16 *data = (void *)(long)ctx->data;
        //     if (bpf_ntohs(*data) == 0xeB9F) {
        //         *data = 0xffff;
        //     }
        //
        //     return XDP_PASS;
        // }
        // explicitly skip rustfmt checks as we want to format the
        // array per-instruction. Ideally, this should be generated.
        #[rustfmt::skip]
        let prog: [u8; 12 * INSN_SIZE] = [
              0x15, 0x01, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
              0x61, 0x12, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
              0x61, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              0xbf, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              0x07, 0x03, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
              0x2d, 0x23, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
              0x69, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              0x55, 0x02, 0x02, 0x00, 0xeb, 0x9f, 0x00, 0x00,
              0xb7, 0x02, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
              0x6b, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              0xb7, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
              0x95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let mut attrs: bpf_gen::bpf_attr = unsafe { std::mem::zeroed() };
        let load_attrs = unsafe { &mut attrs.__bindgen_anon_3 };

        load_attrs.prog_type = bpf_gen::bpf_prog_type::BPF_PROG_TYPE_XDP as u32;

        let prog_name = CString::new("xdp_simple").expect("new string for prog name failed");
        unsafe {
            ptr::copy_nonoverlapping(
                prog_name.as_ptr(),
                load_attrs.prog_name.as_mut_ptr(),
                load_attrs.prog_name.len(),
            )
        };
        load_attrs.insns = prog.as_ptr() as u64;
        load_attrs.insn_cnt = (prog.len() / INSN_SIZE) as u32;
        let license = CString::new("GPL").expect("new string for license failed");
        load_attrs.license = license.as_ptr() as u64;
        load_attrs.log_level = 2;
        load_attrs.log_buf = log_buff.as_ptr() as u64;
        load_attrs.log_size = LOG_SIZE as u32;

        let res = bpf(bpf_gen::bpf_cmd::BPF_PROG_LOAD, &attrs);
        println!("{}", str::from_utf8(&log_buff).unwrap());

        assert!(res.is_ok());

        let fd = res.unwrap();
        const DATA_SZ: usize = 2;

        let data_in: [u8; DATA_SZ] = [0xeB, 0x9F];
        let data_out: [u8; DATA_SZ] = [0; 2];

        attrs = unsafe { std::mem::zeroed() };
        let test_attrs = unsafe { &mut attrs.test };

        test_attrs.data_in = data_in.as_ptr() as u64;
        test_attrs.data_size_in = data_in.len() as u32;
        test_attrs.data_out = data_out.as_ptr() as u64;
        test_attrs.data_size_out = data_out.len() as u32;
        test_attrs.prog_fd = fd;

        assert!(bpf(bpf_gen::bpf_cmd::BPF_PROG_TEST_RUN, &attrs).is_ok());
        assert_eq!(u16::from_ne_bytes(data_out), 0xffff);

        bpf_unload(fd).expect("failed to unload bpf program");
    }
}
